# 关于可扩展性的思考

> 2017/1/3
>
> 程序设计源于生活 —— Love Coding, Love my Beautiful Life.

[heading-numbering]

## [no-toc] [no-number] TOC

[TOC]

## Warning: TL;DR 😅

2016 年收获很大，从实践中学到了很多知识，加深了对程序设计的感悟。参加了好几次 hackathon，认识了很多朋友。

还记得国庆的第二天，仅是因为突发奇想，开始了神奇的 [C++ ORM 设计](https://github.com/BOT-Man-JL/ORM-Lite)，于是搭上了**两个月**来完善，并领会到了 C++ 元编程的强大威力。

十二月很忙，不知不觉就过去了，每天都在填各种不同的坑，填着填着也学到了不少的东西 —— 因为**大作业**需求，写了一个不错的 [多人即时对战游戏](https://github.com/BOT-Man-JL/BUPT-Projects/blob/master/3-1-Pokemon)，用上了不少的设计思想和编码技巧。

从 2016 年的学习中，我认识到了：一切设计都源于生活，只有热爱生活，热爱自己，才能设计出被人们热爱的东西。

## 先谈重构 —— 磨刀不误砍柴工

重构是什么？ —— 通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。

我的最近一次重构是在写**对战游戏大作业**的时候：
- 9 月下旬大作业的题目布置下来了，我花了两周时间很快的学习了 Socket 和 数据库，并完成了基本的阶段一、二的需求。由于对阶段三的对战业务的设计还没有什么思路，就放慢了这个项目的进度。
- 10 月、11 月偶尔抽了点时间，实现了基于 [Lockstep 协议](https://en.wikipedia.org/wiki/Lockstep_protocol)的同步模型（最后因为发现这个模型存在严重的问题 —— 服务器无法判断游戏是否结束 😂）。
- 直到了 12 月，该还的债还是要还 —— 我不得不继续拾起原来的代码。而就在这个时候，我发现原来的代码可扩展性太差了。磨刀不误砍柴工，于是我就开始了重构。

### 原设计上存在的主要问题

- 使用了自定义传输格式，实现服务器和客户端的**通信协议**。
  - 对于复杂的传输格式，解析麻烦。例如，用换行符 `\n` 隔开每主个字段，用制表符 `\t` 隔开主字段内各个从字段，用回车符 `\r` 隔开从字段内各个分字段。
  - 依赖于字段顺序和数目，可扩展性极差。例如，规定了某个字段可以重复出现几次，并从第几个到第几个，读取时跳过第几个去读第几个。
- 服务器处理业务逻辑的实现，可扩展性不强。
  - 当增加业务逻辑的时候，需要改动之前的代码才能处理新业务。
  - 当新业务很复杂的时候，对原代码的改动会牵连很多地方，导致逻辑混乱。（如果让我去写逻辑混乱的代码，我会很烦；如果我很烦，我只能写出混乱的代码了 😝）

### 针对这两个问题的重构方法

- 改用 [json 格式](https://en.wikipedia.org/wiki/JSON)实现数据协议。
  - json 数据中包含了元数据，可以利用元数据对数据进行描述，这样利于扩展；例如，我们不再规定字段位置、顺序，新增业务的时候只需要加上新的字段就可以了。
  - json 在 C++ 中有着[很好用的库](https://github.com/nlohmann/json)，不需要编写大量代码就可以生成 / 解析 json 了。
- 改用 [控制反转](https://martinfowler.com/bliki/InversionOfControl.html) 方式注入业务逻辑控制器。
  - 将请求转发给实际的控制器处理，而转发请求的框架不涉及任何业务逻辑。😂
  - 这样实现了**低耦合** **可扩展**的服务器设计。😊

尽管重构花去了近一周的时间，但是重构之后的代码为之后的业务扩展（实现多人实时对战）铺平了宽敞的大道。😎

以上两个设计在本质上有着共同之处 —— **可扩展性** —— **数据**可扩展和**计算**可扩展。

## 半结构化 —— 数据可扩展性

上周一直在写网络存储课程的读书笔记（美其名曰：大作业论文 😌），于是趁机反思了一些关于数据的东西。论文要求是 [为大型在线考试设计一个系统](../2016/Exam-System-Design.md)，其中需要**存储考生提交的答案**。

针对于这类数据，可以使用 NoSQL 数据库存储 —— 把每份答案作为一个 json 文档放入数据库。

### 让数据描述自己

NoSQL 和 SQL 最大的区别在于：前者可以存储**非结构化 / 半结构化**的数据，后者只能根据数据关系存储数据。每场考试有着不同的考题，题目数量、类型各式各样，很难找到一个**通用的关系模型**来统一存放这些数据。

所以，机智的人们就想到了一种**通用的方法**来处理这个问题 —— 让数据描述自己，即数据中包含元数据，通过元数据描述数据的具体格式。

实际上，这种设计早已被广泛的应用了。例如，我们每天都离不开的 **html** 页面包含了各种 tag（标签）用于解释文本的内容，而浏览器只需要根据标签描述的属性，对页面内的数据进行渲染，就可以展现丰富多彩的页面了。

之前提到的 json 就属于这种半结构化的数据类型，早已被广泛的应用于数据的**传输**和**存储**。

### 设计源于生活

这样的设计相对于令人费解的关系模型，更符合正常的思维方式。

例如，一个很大的超市，往往会在入口处放一个大牌子 —— 往这边走进入超市。进去之后，又有一个大牌子 —— 家电在左边，生活用品在右边，其他类型往前走。再往前走，又来了一个大牌子 —— 生鲜在左边，水果在右边，其他商品在前边。

对于第一次来到这家超市的人，牌子上的信息很重要，他们可以按照牌子的指示，最快的找到需要的商品。（当然，对于很多经常光顾这家超市的人来说，牌子上的信息完全是冗余的 —— 他们完全可以通过经验，很快的找到需要的东西。😂）

对于这样的设计有着良好的可扩展性：假设超市新开了一个区域，用于销售儿童玩具；如果没有这些描述区域的大牌子，那么不管是新顾客还是老顾客都难以发现这块新的区域。

仔细想想，人类之所以能看到面包就知道它能吃，看到牛奶就知道它能喝，实际上也是因为它们有着**自我描述的属性** —— 让人一看就知道是什么。

适当的增加冗余，留有余地，只为更好的扩展。

## 控制反转 —— 计算可扩展性

控制反转是什么？简单的说，就是好莱坞原则 —— _Don't call us, we will call you._ 🙂 （留下你的电话号码，我们有需求就会打电话给你）

对于大作业中的业务逻辑实现：
- 改进前的方式：
  - 来了一个请求，
    - 首先判断这是什么业务，
    - 然后根据业务要求，解析请求，生成响应，
    - 最后回复给发送者。
- 改进后的方式：
  - 来请求之前，
    - 所有业务控制器先向处理框架 **注册**；
  - 然后来一个请求，
    - 首先判断这是什么业务，
    - 然后 **转发** 给对这个请求感兴趣的业务控制器处理，
    - 最后把处理结果会给发送者。

为什么要控制反转？

- 由于业务逻辑处理上有着共同之处（例如，检查用户是否登录），我们需要把相同的逻辑抽象成 **统一的处理框架**
- 框架是所有业务 **共有处理流程** 的抽象，并不涉及具体的业务；如果需要处理具体的业务，需要把具体的业务处理逻辑 **注入到框架**
  - 一种方法是：使用 [模板方法 (template method)](Design-Patterns-Notes-3.md#Template-Method) 模式，通过 **继承**，**重载** 具体业务的处理逻辑
  - 另一种方法是：使用 [依赖注入 (dependency injection)](https://martinfowler.com/articles/injection.html) 方法，通过 **组合**，**传入** 具体业务处理的对象
- 根据消息专家原则 —— 与其 让不知道如何去做的人学习如何去做，不如 让知道如何做一件事情的人去做，从而 **减少知识传递的开销**

### IoC/DIP 其实是一种管理思想

分享一下之前看到的**非常不错**的文章：[IoC/DIP 其实是一种管理思想](http://coolshell.cn/articles/9949.html)

里边举的例子很好的说明了什么是 IoC（控制反转）：

1. 起初，人们为电灯设计了开关 —— 按一下开灯，再按一下关灯。
2. 于是出现了电视，人们为电视也设计了开关 —— 按一下打开，再按一下关掉。
3. 这时机智的人们就想到了一种**通用的方法**来解决这个问题 —— 只需要设计一个开关接口，让电灯、电视接进来就可以了。这样的设计解开了开关和电灯的耦合，人们可以专心的分别设计各式各样的开关和各式各样的电灯、电视了。

里边的另一段写的很精彩，让我印象深刻：

> 有一个项目是在给Amazon的各个商区（Marketplace）做国际出口的业务，我们先把 Media 类的产品（书，DVD 之类的）做国际出口开放，项目不难，就是让商家同意一个法律协议（上传自己的签名），然后后台小改一下。
>
> 美国的，欧洲的做的都没有问题，物流团队在出口报关单上打的都是 Amazon 仓库的地址和商家的签名（本来这就是错的，打的应该是商家的地址和商家的签名），但是到了日本，就出了问题，因为日本海关即要日文信息，也要商家的英文名和英文地址，而我们的系统里面只有商家的日文信息。
>
> 本来，这是一个挺简单的事——数据库里加两个字段，在那个同意条款的网页上收集一下商家的英文名和地址，然后把这些信息传给后面的物流团队。物流团队一看这个，发现搞不了，因为他还要传给仓库，N多的地方都要加这两个字段，还要写下各种 if (site == JP) 这样的判断。
>
> 物流团队不蛮干，重新设计自己的系统。做一个 Document Template 的东西，这个就是那个那个要贴在物流盒子上的单子。再也不让各个业务团队把那些信息传过来，而是把这个 Document Template 的东西传给上面的业务方，他们想怎么写就怎么写， 写完后，把这个东西传回来。于是，大家依赖了一个标准的协议，而不是一其字段。（当然，这个改动过多，为此改了半年多，不过非常值）

这个设计十分的巧妙：
- 一方面，引入了带有 **元数据** 的文档模板，将物流单子上的信息变为半结构化
- 另一方面，与其 **区别对待** 特殊情况，不如把控制反转一下 —— 只要业务团队按照规定格式填充模板，物流团队就“照收不误”

### 设计源于生活

很多时候，不必事必躬亲；有的人专注于总体规划，有的人专注于执行细节。

例如，一个刚刚创业的面包店老板，
- 一开始只有一个人自己干：
  - 有人要订抹茶蛋糕，他会做这种蛋糕，就去做了，然后给了客户；
  - 有人要订原味蛋糕，他也会做，就去做了，然后发给客户；
  - 有一天，有人要订巧克力蛋糕，他就不会了，他需要去学习如何做这种蛋糕。
- 一段时间后，他发现客户越来越多，蛋糕口味越来越复杂，一个人应付不过来。
- 于是，老板打算找人帮忙：
  - 他在网上发了个公告，招人帮忙做蛋糕；
  - 他要求来帮忙的人需要先留下电话号码，并且能按照他的需求完成蛋糕；
  - 有人要订某种蛋糕，老板只需要拿起电话，打给帮忙做蛋糕的人，然后把口味、大小告诉他；
  - 帮忙做蛋糕的人根据他说的，做好蛋糕，送过来；
  - 于是老板可以直接把蛋糕交给客户了。

再如，制造硬件的人，不必为它的硬件开发系统；开发系统的人，不必为它的系统写每一个用户软件。更好的方式是：我把标准定了，你们按照这个标准，把你们的东西装载进去，只要符合规范，“想干什么随你”。

最后引用 [需求变化与 IoC](http://coolshell.cn/articles/6950.html) 的这段话：

> 我们的人生都被环境和各种客观条件所束缚，多数人只能随波逐流，听从命运的安排。你有没有想过要拥有人生的主导权呢？既然你是程序员，你懂IoC，你能否设计自己的人生框架呢？Yes，you can!

## 写在最后

> 学而不思则罔。

这里总结了 2016 下半年的一些实践经验，和大家分享。如果有什么问题，望**不吝赐教**。😄

> 人们眼中的天才之所以卓越非凡，并非天资超人一等，而是付出了持续不断的努力。**一万小时**的锤炼是任何人从平凡变成世界级大师的必要条件。 —— 格拉德威尔 《异类》

2017 为了达成一万小时的目标而努力。😇

Delivered under MIT License &copy; 2017, BOT Man
